/**
 * @name string-range-expander
 * @fileoverview Expands string index ranges within whitespace boundaries until letters are met
 * @version 4.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/string-range-expander/}
 */

"use strict";var stringRangeExpander=(()=>{var v=Object.create;var m=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var L=Object.getOwnPropertyNames,I=Object.getOwnPropertySymbols,k=Object.getPrototypeOf,O=Object.prototype.hasOwnProperty,W=Object.prototype.propertyIsEnumerable;var $=(e,o,l)=>o in e?m(e,o,{enumerable:!0,configurable:!0,writable:!0,value:l}):e[o]=l,b=(e,o)=>{for(var l in o||(o={}))O.call(o,l)&&$(e,l,o[l]);if(I)for(var l of I(o))W.call(o,l)&&$(e,l,o[l]);return e};var B=(e,o)=>()=>(o||e((o={exports:{}}).exports,o),o.exports),V=(e,o)=>{for(var l in o)m(e,l,{get:o[l],enumerable:!0})},w=(e,o,l,i)=>{if(o&&typeof o=="object"||typeof o=="function")for(let r of L(o))!O.call(e,r)&&r!==l&&m(e,r,{get:()=>o[r],enumerable:!(i=j(o,r))||i.enumerable});return e};var _=(e,o,l)=>(l=e!=null?v(k(e)):{},w(o||!e||!e.__esModule?m(l,"default",{value:e,enumerable:!0}):l,e)),H=e=>w(m({},"__esModule",{value:!0}),e);var x=B((Q,C)=>{"use strict";C.exports=N;function T(e){return e instanceof Buffer?Buffer.from(e):new e.constructor(e.buffer.slice(),e.byteOffset,e.length)}function N(e){if(e=e||{},e.circles)return P(e);let o=new Map;if(o.set(Date,t=>new Date(t)),o.set(Map,(t,a)=>new Map(i(Array.from(t),a))),o.set(Set,(t,a)=>new Set(i(Array.from(t),a))),e.constructorHandlers)for(let t of e.constructorHandlers)o.set(t[0],t[1]);let l=null;return e.proto?c:r;function i(t,a){let s=Object.keys(t),n=new Array(s.length);for(let f=0;f<s.length;f++){let u=s[f],d=t[u];typeof d!="object"||d===null?n[u]=d:d.constructor!==Object&&(l=o.get(d.constructor))?n[u]=l(d,a):ArrayBuffer.isView(d)?n[u]=T(d):n[u]=a(d)}return n}function r(t){if(typeof t!="object"||t===null)return t;if(Array.isArray(t))return i(t,r);if(t.constructor!==Object&&(l=o.get(t.constructor)))return l(t,r);let a={};for(let s in t){if(Object.hasOwnProperty.call(t,s)===!1)continue;let n=t[s];typeof n!="object"||n===null?a[s]=n:n.constructor!==Object&&(l=o.get(n.constructor))?a[s]=l(n,r):ArrayBuffer.isView(n)?a[s]=T(n):a[s]=r(n)}return a}function c(t){if(typeof t!="object"||t===null)return t;if(Array.isArray(t))return i(t,c);if(t.constructor!==Object&&(l=o.get(t.constructor)))return l(t,c);let a={};for(let s in t){let n=t[s];typeof n!="object"||n===null?a[s]=n:n.constructor!==Object&&(l=o.get(n.constructor))?a[s]=l(n,c):ArrayBuffer.isView(n)?a[s]=T(n):a[s]=c(n)}return a}}function P(e){let o=[],l=[],i=new Map;if(i.set(Date,s=>new Date(s)),i.set(Map,(s,n)=>new Map(c(Array.from(s),n))),i.set(Set,(s,n)=>new Set(c(Array.from(s),n))),e.constructorHandlers)for(let s of e.constructorHandlers)i.set(s[0],s[1]);let r=null;return e.proto?a:t;function c(s,n){let f=Object.keys(s),u=new Array(f.length);for(let d=0;d<f.length;d++){let p=f[d],h=s[p];if(typeof h!="object"||h===null)u[p]=h;else if(h.constructor!==Object&&(r=i.get(h.constructor)))u[p]=r(h,n);else if(ArrayBuffer.isView(h))u[p]=T(h);else{let S=o.indexOf(h);S!==-1?u[p]=l[S]:u[p]=n(h)}}return u}function t(s){if(typeof s!="object"||s===null)return s;if(Array.isArray(s))return c(s,t);if(s.constructor!==Object&&(r=i.get(s.constructor)))return r(s,t);let n={};o.push(s),l.push(n);for(let f in s){if(Object.hasOwnProperty.call(s,f)===!1)continue;let u=s[f];if(typeof u!="object"||u===null)n[f]=u;else if(u.constructor!==Object&&(r=i.get(u.constructor)))n[f]=r(u,t);else if(ArrayBuffer.isView(u))n[f]=T(u);else{let d=o.indexOf(u);d!==-1?n[f]=l[d]:n[f]=t(u)}}return o.pop(),l.pop(),n}function a(s){if(typeof s!="object"||s===null)return s;if(Array.isArray(s))return c(s,a);if(s.constructor!==Object&&(r=i.get(s.constructor)))return r(s,a);let n={};o.push(s),l.push(n);for(let f in s){let u=s[f];if(typeof u!="object"||u===null)n[f]=u;else if(u.constructor!==Object&&(r=i.get(u.constructor)))n[f]=r(u,a);else if(ArrayBuffer.isView(u))n[f]=T(u);else{let d=o.indexOf(u);d!==-1?n[f]=l[d]:n[f]=a(u)}}return o.pop(),l.pop(),n}}});var q={};V(q,{defaults:()=>D,expander:()=>J,version:()=>F});var A=_(x(),1);var K=(0,A.default)();function R(e){if(e==null||typeof e!="object")return!1;let o=Object.getPrototypeOf(e);return o!==null&&o!==Object.prototype&&Object.getPrototypeOf(o)!==null?!1:!(Symbol.iterator in e)&&!(Symbol.toStringTag in e)}function g(e){return typeof e=="string"}function y(e){return Number.isSafeInteger(e)&&e>=0}var E="4.1.0";var F=E,D={str:"",from:0,to:0,ifLeftSideIncludesThisThenCropTightly:"",ifLeftSideIncludesThisCropItToo:"",ifRightSideIncludesThisThenCropTightly:"",ifRightSideIncludesThisCropItToo:"",extendToOneSide:!1,wipeAllWhitespaceOnLeft:!1,wipeAllWhitespaceOnRight:!1,addSingleSpaceToPreventAccidentalConcatenation:!1};function J(e){var a,s;let o=/^[0-9a-zA-Z]+$/;function l(n){return g(n)&&!n.trim()}if(R(e)){if(!Object.keys(e).length)throw new Error('string-range-expander: [THROW_ID_02] Input must be a plain object but it\'s been given as a plain object without any keys. However, "from" and "to" settings are obligatory!')}else{let n;throw e===void 0?n="but it is missing completely.":e===null?n="but it was given as null.":n="but it was given as ".concat(typeof e,", equal to:\n").concat(JSON.stringify(e,null,4),"."),new Error("string-range-expander: [THROW_ID_01] Input must be a plain object ".concat(n))}if(!y(e.from))throw new Error("string-range-expander: [THROW_ID_03] The input's \"from\" value resolvedOpts.from, is not a number! It's been given as ".concat(typeof e.from,", equal to ").concat(JSON.stringify(e.from,null,0)));if(!y(e.to))throw new Error("string-range-expander: [THROW_ID_04] The input's \"to\" value resolvedOpts.to, is not a number! It's been given as ".concat(typeof e.to,", equal to ").concat(JSON.stringify(e.to,null,0)));if(e!=null&&e.str&&!e.str[e.from]&&e.from!==e.to)throw new Error('string-range-expander: [THROW_ID_05] The given input string resolvedOpts.str ("'.concat(e.str,'") must contain the character at index "from" ("').concat(e.from,'")'));if(e!=null&&e.str&&!e.str[e.to-1])throw new Error('string-range-expander: [THROW_ID_06] The given input string, resolvedOpts.str ("'.concat(e.str,'") must contain the character at index before "to" ("').concat(e.to-1,'")'));if(e.from>e.to)throw new Error('string-range-expander: [THROW_ID_07] The given "from" index, "'.concat(e.from,'" is greater than "to" index, "').concat(e.to,"\". That's wrong!"));if(e.extendToOneSide===null||g(e.extendToOneSide)&&e.extendToOneSide!=="left"&&e.extendToOneSide!=="right"||!g(e.extendToOneSide)&&e.extendToOneSide!==void 0&&e.extendToOneSide)throw new Error('string-range-expander: [THROW_ID_08] The options value "extendToOneSide" is not recognisable! It\'s set to: "'.concat(e.extendToOneSide,'" (').concat(typeof e.extendToOneSide,'). It has to be either Boolean "false" or one of strings: "left" or "right"'));if(e!=null&&e.ifLeftSideIncludesThisThenCropTightly&&!g(e.ifLeftSideIncludesThisThenCropTightly))throw new Error('string-range-expander: [THROW_ID_09] The option "ifLeftSideIncludesThisThenCropTightly", is not a string! It\'s been given as '.concat(typeof e.ifLeftSideIncludesThisThenCropTightly,", equal to ").concat(JSON.stringify(e.ifLeftSideIncludesThisThenCropTightly,null,0)));if(e!=null&&e.ifLeftSideIncludesThisCropItToo&&!g(e.ifLeftSideIncludesThisCropItToo))throw new Error('string-range-expander: [THROW_ID_10] The option "ifLeftSideIncludesThisCropItToo", is not a string! It\'s been given as '.concat(typeof e.ifLeftSideIncludesThisCropItToo,", equal to ").concat(JSON.stringify(e.ifLeftSideIncludesThisCropItToo,null,0)));if(e!=null&&e.ifRightSideIncludesThisThenCropTightly&&!g(e.ifRightSideIncludesThisThenCropTightly))throw new Error('string-range-expander: [THROW_ID_11] The option "ifRightSideIncludesThisThenCropTightly", is not a string! It\'s been given as '.concat(typeof e.ifRightSideIncludesThisThenCropTightly,", equal to ").concat(JSON.stringify(e.ifRightSideIncludesThisThenCropTightly,null,0)));if(e!=null&&e.ifRightSideIncludesThisCropItToo&&!g(e.ifRightSideIncludesThisCropItToo))throw new Error('string-range-expander: [THROW_ID_12] The option "ifRightSideIncludesThisCropItToo", is not a string! It\'s been given as '.concat(typeof e.ifRightSideIncludesThisCropItToo,", equal to ").concat(JSON.stringify(e.ifRightSideIncludesThisCropItToo,null,0)));let i=b(b({},D),e),r=i.str,c=i.from,t=i.to;if(i.extendToOneSide!=="right"&&(l(r[c-1])&&(l(r[c-2])||i.ifLeftSideIncludesThisCropItToo.includes(r[c-2]))||r[c-1]&&i.ifLeftSideIncludesThisCropItToo.includes(r[c-1])||i.wipeAllWhitespaceOnLeft&&l(r[c-1]))){for(let n=c;n--;)if(!i.ifLeftSideIncludesThisCropItToo.includes(r[n])){if(r[n].trim()){i.wipeAllWhitespaceOnLeft||i.ifLeftSideIncludesThisCropItToo.includes(r[n+1])?c=n+1:c=n+2;break}else if(n===0){i.wipeAllWhitespaceOnLeft?c=0:c=1;break}}}if(i.extendToOneSide!=="left"&&(l(r[t])&&(i.wipeAllWhitespaceOnRight||l(r[t+1]))||i.ifRightSideIncludesThisCropItToo.includes(r[t]))){for(let n=t,f=r.length;n<f;n++)if(!i.ifRightSideIncludesThisCropItToo.includes(r[n])){if(r[n].trim()){i.wipeAllWhitespaceOnRight||i.ifRightSideIncludesThisCropItToo.includes(r[n-1])?t=n:t=n-1;break}else if(n===r.length-1){i.wipeAllWhitespaceOnRight?t=r.length:t=r.length-1;break}}}return(i.extendToOneSide!=="right"&&g(i.ifLeftSideIncludesThisThenCropTightly)&&i.ifLeftSideIncludesThisThenCropTightly&&(r[c-2]&&i.ifLeftSideIncludesThisThenCropTightly.includes(r[c-2])||r[c-1]&&i.ifLeftSideIncludesThisThenCropTightly.includes(r[c-1]))||i.extendToOneSide!=="left"&&g(i.ifRightSideIncludesThisThenCropTightly)&&i.ifRightSideIncludesThisThenCropTightly&&(r[t+1]&&i.ifRightSideIncludesThisThenCropTightly.includes(r[t+1])||r[t]&&i.ifRightSideIncludesThisThenCropTightly.includes(r[t])))&&(i.extendToOneSide!=="right"&&l(r[c-1])&&!i.wipeAllWhitespaceOnLeft&&(c-=1),i.extendToOneSide!=="left"&&l(r[t])&&!i.wipeAllWhitespaceOnRight&&(t+=1)),i.addSingleSpaceToPreventAccidentalConcatenation&&((a=r[c-1])!=null&&a.trim())&&((s=r[t])!=null&&s.trim())&&(!i.ifLeftSideIncludesThisThenCropTightly&&!i.ifRightSideIncludesThisThenCropTightly||!((!i.ifLeftSideIncludesThisThenCropTightly||i.ifLeftSideIncludesThisThenCropTightly.includes(r[c-1]))&&(!i.ifRightSideIncludesThisThenCropTightly||r[t]&&i.ifRightSideIncludesThisThenCropTightly.includes(r[t]))))&&(o.test(r[c-1])||o.test(r[t]))?[c,t," "]:[c,t]}return H(q);})();
/**
 * @name codsen-utils
 * @fileoverview Various utility functions
 * @version 1.7.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/codsen-utils/}
 */
