/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 7.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */

"use strict";var rangesPush=(()=>{var B=Object.create;var T=Object.defineProperty;var L=Object.getOwnPropertyDescriptor;var W=Object.getOwnPropertyNames,S=Object.getOwnPropertySymbols,_=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty,H=Object.prototype.propertyIsEnumerable;var R=(r,e,o)=>e in r?T(r,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):r[e]=o,m=(r,e)=>{for(var o in e||(e={}))v.call(e,o)&&R(r,o,e[o]);if(S)for(var o of S(e))H.call(e,o)&&R(r,o,e[o]);return r};var M=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),P=(r,e)=>{for(var o in e)T(r,o,{get:e[o],enumerable:!0})},N=(r,e,o,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let c of W(e))!v.call(r,c)&&c!==o&&T(r,c,{get:()=>e[c],enumerable:!(i=L(e,c))||i.enumerable});return r};var U=(r,e,o)=>(o=r!=null?B(_(r)):{},N(e||!r||!r.__esModule?T(o,"default",{value:r,enumerable:!0}):o,r)),q=r=>N(T({},"__esModule",{value:!0}),r);var w=(r,e,o)=>R(r,typeof e!="symbol"?e+"":e,o);var V=M((re,j)=>{"use strict";j.exports=G;function b(r){return r instanceof Buffer?Buffer.from(r):new r.constructor(r.buffer.slice(),r.byteOffset,r.length)}function G(r){if(r=r||{},r.circles)return Q(r);let e=new Map;if(e.set(Date,l=>new Date(l)),e.set(Map,(l,a)=>new Map(i(Array.from(l),a))),e.set(Set,(l,a)=>new Set(i(Array.from(l),a))),r.constructorHandlers)for(let l of r.constructorHandlers)e.set(l[0],l[1]);let o=null;return r.proto?n:c;function i(l,a){let t=Object.keys(l),u=new Array(t.length);for(let s=0;s<t.length;s++){let g=t[s],f=l[g];typeof f!="object"||f===null?u[g]=f:f.constructor!==Object&&(o=e.get(f.constructor))?u[g]=o(f,a):ArrayBuffer.isView(f)?u[g]=b(f):u[g]=a(f)}return u}function c(l){if(typeof l!="object"||l===null)return l;if(Array.isArray(l))return i(l,c);if(l.constructor!==Object&&(o=e.get(l.constructor)))return o(l,c);let a={};for(let t in l){if(Object.hasOwnProperty.call(l,t)===!1)continue;let u=l[t];typeof u!="object"||u===null?a[t]=u:u.constructor!==Object&&(o=e.get(u.constructor))?a[t]=o(u,c):ArrayBuffer.isView(u)?a[t]=b(u):a[t]=c(u)}return a}function n(l){if(typeof l!="object"||l===null)return l;if(Array.isArray(l))return i(l,n);if(l.constructor!==Object&&(o=e.get(l.constructor)))return o(l,n);let a={};for(let t in l){let u=l[t];typeof u!="object"||u===null?a[t]=u:u.constructor!==Object&&(o=e.get(u.constructor))?a[t]=o(u,n):ArrayBuffer.isView(u)?a[t]=b(u):a[t]=n(u)}return a}}function Q(r){let e=[],o=[],i=new Map;if(i.set(Date,t=>new Date(t)),i.set(Map,(t,u)=>new Map(n(Array.from(t),u))),i.set(Set,(t,u)=>new Set(n(Array.from(t),u))),r.constructorHandlers)for(let t of r.constructorHandlers)i.set(t[0],t[1]);let c=null;return r.proto?a:l;function n(t,u){let s=Object.keys(t),g=new Array(s.length);for(let f=0;f<s.length;f++){let p=s[f],y=t[p];if(typeof y!="object"||y===null)g[p]=y;else if(y.constructor!==Object&&(c=i.get(y.constructor)))g[p]=c(y,u);else if(ArrayBuffer.isView(y))g[p]=b(y);else{let D=e.indexOf(y);D!==-1?g[p]=o[D]:g[p]=u(y)}}return g}function l(t){if(typeof t!="object"||t===null)return t;if(Array.isArray(t))return n(t,l);if(t.constructor!==Object&&(c=i.get(t.constructor)))return c(t,l);let u={};e.push(t),o.push(u);for(let s in t){if(Object.hasOwnProperty.call(t,s)===!1)continue;let g=t[s];if(typeof g!="object"||g===null)u[s]=g;else if(g.constructor!==Object&&(c=i.get(g.constructor)))u[s]=c(g,l);else if(ArrayBuffer.isView(g))u[s]=b(g);else{let f=e.indexOf(g);f!==-1?u[s]=o[f]:u[s]=l(g)}}return e.pop(),o.pop(),u}function a(t){if(typeof t!="object"||t===null)return t;if(Array.isArray(t))return n(t,a);if(t.constructor!==Object&&(c=i.get(t.constructor)))return c(t,a);let u={};e.push(t),o.push(u);for(let s in t){let g=t[s];if(typeof g!="object"||g===null)u[s]=g;else if(g.constructor!==Object&&(c=i.get(g.constructor)))u[s]=c(g,a);else if(ArrayBuffer.isView(g))u[s]=b(g);else{let f=e.indexOf(g);f!==-1?u[s]=o[f]:u[s]=a(g)}}return e.pop(),o.pop(),u}}});var Z={};P(Z,{Ranges:()=>E,defaults:()=>J,version:()=>Y});function A(r,e=1){let o="\xA0";function i(n){return Array.from(n).reverse().join("")}function c(n,l,a){let t=a?"\n":"\r",u=a?"\r":"\n";if(!n)return n;let s=0,g=0,f="";for(let p=0,y=n.length;p<y;p++)(n[p]===t||n[p]===u&&n[p-1]!==t)&&g++,"\r\n".includes(n[p])||n[p]===o?(s=0,n[p]===o?f+=n[p]:n[p]===t?g<=l&&(f+=n[p],n[p+1]===u&&(f+=n[p+1],p++)):n[p]===u&&(n==null?void 0:n[p-1])!==t&&g<=l&&(f+=n[p])):(s++,!n[p+1]&&!g&&(f+=" "));return f}if(typeof r=="string"&&r.length){let n=1;typeof+e=="number"&&Number.isInteger(+e)&&+e>=0&&(n=+e);let l="",a="";if(!r.trim())l=r;else if(!r[0].trim()){for(let t=0,u=r.length;t<u;t++)if(r[t].trim()){l=r.slice(0,t);break}}if(r.trim()&&(r.slice(-1).trim()===""||r.slice(-1)===o)){for(let t=r.length;t--;)if(r[t].trim()){a=r.slice(t+1);break}}return"".concat(c(l,n,!1)).concat(r.trim()).concat(i(c(i(a),n,!0)))}return r}var x=U(V(),1);var ne=(0,x.default)();function $(r){return typeof r=="string"}function C(r){return Number.isFinite(r)}function d(r){return Number.isSafeInteger(r)&&r>=0}function h(r){return r!=null}var z={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function O(r,e){if(!Array.isArray(r)||!r.length)return r;let o=m(m({},z),e),i,c;if(o.strictlyTwoElementsInRangeArrays&&!r.every((a,t)=>!Array.isArray(a)||a.length!==2?(i=t,c=a.length,!1):!0))throw new TypeError("ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ".concat(i,"th range (").concat(JSON.stringify(r[i],null,4),") has not two but ").concat(c," elements!"));if(!r.every((a,t)=>!Array.isArray(a)||!Number.isInteger(a[0])||a[0]<0||!Number.isInteger(a[1])||a[1]<0?(i=t,!1):!0))throw new TypeError("ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ".concat(i,"th range (").concat(JSON.stringify(r[i],null,4),") does not consist of only natural numbers!"));let n=r.length**2,l=0;return Array.from(r).sort((a,t)=>(o.progressFn&&(l+=1,o.progressFn(Math.floor(l*100/n))),a[0]===t[0]?a[1]<t[1]?-1:a[1]>t[1]?1:0:a[0]<t[0]?-1:1))}var I="7.1.0";var k={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function F(r,e){var u;function o(s){return!!s&&typeof s=="object"&&!Array.isArray(s)}if(!Array.isArray(r)||!r.length)return null;let i;if(e)if(o(e)){if(i=m(m({},k),e),i.progressFn&&o(i.progressFn)&&!Object.keys(i.progressFn).length)i.progressFn=null;else if(i.progressFn&&typeof i.progressFn!="function")throw new Error('ranges-merge: [THROW_ID_01] resolvedOpts.progressFn must be a function! It was given of a type: "'.concat(typeof i.progressFn,'", equal to ').concat(JSON.stringify(i.progressFn,null,4)));if(![1,2,"1","2"].includes(i.mergeType))throw new Error('ranges-merge: [THROW_ID_02] resolvedOpts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(typeof i.mergeType,'", equal to ').concat(JSON.stringify(i.mergeType,null,4)));if(typeof i.joinRangesThatTouchEdges!="boolean")throw new Error('ranges-merge: [THROW_ID_04] resolvedOpts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "'.concat(typeof i.joinRangesThatTouchEdges,'", equal to ').concat(JSON.stringify(i.joinRangesThatTouchEdges,null,4)))}else throw new Error("ranges-merge: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n".concat(JSON.stringify(e,null,4)," (type ").concat(typeof e,")"));else i=m({},k);let c=r.filter(s=>Array.isArray(s)).map(s=>[...s]).filter(s=>s[2]!==void 0||s[0]!==s[1]),n,l,a;i.progressFn?n=O(c,{progressFn:s=>{a=Math.floor(s/5),a!==l&&(l=a,i.progressFn!=null&&i.progressFn(a))}}):n=O(c);let t=n.length-1;for(let s=t;s>0;s--)i.progressFn&&(a=Math.floor((1-s/t)*78)+21,a!==l&&a>l&&(l=a,i.progressFn(a))),(n[s][0]<=n[s-1][0]||!i.joinRangesThatTouchEdges&&n[s][0]<n[s-1][1]||i.joinRangesThatTouchEdges&&n[s][0]<=n[s-1][1])&&(n[s-1][0]=Math.min(n[s][0],n[s-1][0]),n[s-1][1]=Math.max(n[s][1],n[s-1][1]),n[s][2]!==void 0&&(n[s-1][0]>=n[s][0]||n[s-1][1]<=n[s][1])&&n[s-1][2]!==null&&(n[s][2]===null&&n[s-1][2]!==null?n[s-1][2]=null:n[s-1][2]!=null?+((u=i||{})==null?void 0:u.mergeType)==2&&n[s-1][0]===n[s][0]?n[s-1][2]=n[s][2]:n[s-1][2]+=n[s][2]:n[s-1][2]=n[s][2]),n.splice(s,1),s=n.length);return n.length?n:null}var Y=I,J={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},E=class{constructor(e){w(this,"ranges");w(this,"opts");let o=m(m({},J),e);if(o.mergeType&&o.mergeType!==1&&o.mergeType!==2)if($(o.mergeType)&&o.mergeType.trim()==="1")o.mergeType=1;else if($(o.mergeType)&&o.mergeType.trim()==="2")o.mergeType=2;else throw new Error('ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(typeof o.mergeType,'", equal to ').concat(JSON.stringify(o.mergeType,null,4)));this.opts=o,this.ranges=[]}add(e,o,i){var l;if(e==null&&o==null)return;if(h(e)&&!h(o)){if(Array.isArray(e)){if(e.length){if(e.some(a=>Array.isArray(a))){e.forEach(a=>{Array.isArray(a)&&this.add(...a)});return}e.length&&d(+e[0])&&d(+e[1])&&this.add(...e)}return}throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set ('.concat(JSON.stringify(e,null,0),') but second-one, "to" is not (').concat(JSON.stringify(o,null,0),")"))}else if(!h(e)&&h(o))throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set ('.concat(JSON.stringify(o,null,0),') but first-one, "from" is not (').concat(JSON.stringify(e,null,0),")"));let c=+e,n=+o;if(d(c)&&d(n)){if(h(i)&&!$(i)&&!C(i))throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ".concat(typeof i,", equal to:\n").concat(JSON.stringify(i,null,4)));if(h(this.ranges)&&Array.isArray(this.last())&&c===this.last()[1]){if(this.last()[1]=n,this.last()[2],this.last()[2]!==null&&h(i)){let a=this.last()[2]&&this.last()[2].length&&(!((l=this.opts)!=null&&l.mergeType)||this.opts.mergeType===1)?"".concat(this.last()[2]).concat(i):i;this.opts.limitToBeAddedWhitespace&&(a=A(a,this.opts.limitLinebreaksCount)),$(a)&&!a.length||(this.last()[2]=a)}}else{this.ranges||(this.ranges=[]);let a=i!==void 0&&!($(i)&&!i.length)?[c,n,i&&this.opts.limitToBeAddedWhitespace?A(i,this.opts.limitLinebreaksCount):i]:[c,n];this.ranges.push(a)}}else throw d(c)&&c>=0?new TypeError('ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(typeof n,'" equal to: ').concat(JSON.stringify(n,null,4))):new TypeError('ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(typeof c,'" equal to: ').concat(JSON.stringify(c,null,4)))}push(e,o,i){this.add(e,o,i)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=F(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(e=>h(e[2])?[e[0],e[1],A(e[2],this.opts.limitLinebreaksCount)]:e):this.ranges):null}wipe(){this.ranges=[]}replace(e){if(Array.isArray(e)&&e.length)if(Array.isArray(e[0])&&d(e[0][0]))this.ranges=Array.from(e);else throw new Error("ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ".concat(JSON.stringify(e[0],null,4)," should be an array and its first element should be an integer, a string index."));else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};return q(Z);})();
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 7.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */
/**
 * @name codsen-utils
 * @fileoverview Various utility functions
 * @version 1.7.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/codsen-utils/}
 */
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 6.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
